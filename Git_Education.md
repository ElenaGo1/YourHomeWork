# Мое руководство по началу работы с Git и VS Code
## Подготовка

> Для того, чтобы разобрать как начать работать с Git системой управления версиями. 
Нам необходимо установить сам [Git](https://git-scm.com/book/ru/v2/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-Git) и редактор исходного кода [Visual Studio Code (VS Code)](https://code.visualstudio.com/), в котором будем создавать документ для последующего его сохранения в версии.
Установку Git и VS Code производим стандартно и в конце перезагружаем компьютер.

## Начало работы с Git и VS Code
---
После того как установили **Git** и **VS Code**, проверим правильно ли установился у нас **Git** и можем мы с ним работать.
Для этого мы откроем редактор **VS Code** и в верхнем горизонтальном меню развернем раздел ***“Терминал”*** и далее выбираем ***“Создать терминал”*** или просто нажать **CTRL+SHIFT**+`, после чего откроется окно **Терминала**. 
Теперь проверим работает ли у нас **Git** и сможем мы с ним продолжить работу. Для этого зададим в терминале команду: 
```git – version
PS C:\Users\Dima\Desktop\Seminar1> git --version
```
После этого мы должны увидеть *версию* **Git** как показано ниже. Что значит, что Git установлен верно и мы можем с ним продолжить работу:
```
git version 2.37.1.windows.1
```
Далее мы в **Git** укажем *Имя* и *адрес электронной почты*, так как эта информация необходима ему для того, чтобы указать в дальнейшем в коммитах и создание коммита будет невозможна без этого и **Git** все равно запросит данную информацию.
Для этого мы зададим команды поочередно:
```
git config --global user.name "Lena"
git config --global user.email lena@mail.ru
```

## Создание директории (папки) для в VS Code 
## и создание репозитория в Git.
---

Чтобы продолжить работу и создавать проекты в **VS Code** создадим на рабочем столе или в любом другом месте на компьютере директорию (папку) и назовем её ***"SEMINAR1"***.

Перейдем обратно в **VS Code** и откроем нашу папку из редактора. Для этого в левом горизонтальном меню выбираем раздел **Explorer (проводник)** и разворачиваем его, далее нажимаем **Open Folder (Открыть папку)** и выбираем нашу созданную папку ***"SEMINAR1"***.
 Далее нам в **Git** необходимо создать репозиторий, хранилище нашего проекта, историю его изменения и самого файла. Для этого зададим команду ``` git init``` и нажать кнопку **<d style="color:yellow">Enter</d>**. После выполнения данной команды в рабочей папке ***SEMINAR1*** появится скрытая папка ***.git*** 
***(X:\...\ SEMINAR1\.git)***, в ней и будут храниться все сохраненные **коммиты (точки сохранения изменений)** и вся история процесса изменения нашего файла.
Мы можем узнать статус нашей рабочей папки и что в ней происходит командой ```git status```.

**Мы увидим:**
```
PS C:\Users\Dima\Desktop\SEMINAR1> git status
On branch master

No commits yet

nothing to commit (create/copy files and use "git add" to track)
PS C:\Users\Dima\Desktop\SEMINAR1>
```
>**Git** сообщает нам, что мы находимся на главном ветви **master**, пока никаких коммитов нет, 
ничего не нужно фиксировать. Создайте файл и используйте комманду```"git add"``` для отслеживания данного файла.

## Создание файла и отслеживание его
---

Давайте и поступим так, создадим файл **Git_Education.md**. Для этого в **VS Code** в **Explorer (Проводнике)** где у нас открыта наша папка в меню выберем **Создать файл** и зададим имя нашего файла **Git_Education.md** и нажмем **<d style="color:yellow">Enter</d>**.
И снова проверим статус нашей рабочей папки командой ```git status```.

**Мы увидим:**
```
PS C:\Users\Dima\Desktop\SEMINAR1> git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        Git_Education.md

nothing added to commit but untracked files present (use "git add" to track)
PS C:\Users\Dima\Desktop\ SEMINAR1>
```
**Git** сообщает нам что есть не отслеживаемый файл и чтобы он начал следить за изменениями происходящими в нем нужно воспользоваться командой ```git add```.  Также об этом сообщает нам маркер **U** - *это говорит о том что файл существует, но не отслеживается еще*.
Для этого воспользуемся подсказкой **Git** и наберем команду ```git add``` и **имя файла** но полностью писать не будем наберем две первые буквы файла и нажмем кнопку **Tab**: ```git add .\Git_Education.md``` терминал самостоятельно добавит полное имя файла, нажимаем **<d style="color:yellow">Enter</d>**. Если сообщений об ошибки нет, значит все сделали верно.

Также вы видим маркер **А** – *это значит, что файл добавлен к отслеживанию и можно создать коммит*.
Посмотрим на статус **Git**, после данной операции, и взглянем на то, что же поменялось. Возвращаемся к команде ```git status```. И видим, что **Git** начал отслеживать наш файл, он говорит, что некоторые изменения могут быть сохранены и видит файл, который называется ```Git_Education.md```. **Git** начал отслеживать данный файл и мы можем сохранить изменения, которые мы совершим.

Теперь можем добавить начальный **коммит (контрольную точку)**. Для этого зададим команду в терминале: ```git commit -m "initial commit"```. Мы видим, что с файлом нашим идет некоторая работа, и мы внесли новый коммит **(начальный)**.

## Продолжение работы с Git  и VS Code 
### Внесение изменений в файл и сохранение их в Git
---
Давайте добавим в наш файл новый заголовок например: **# Мое руководство по работе с Git** и обязательно нажмите **CTRL+S**, чтобы сохранить внесенные изменения. Иначе **Git** не поймет, что мы их внесли.

Теперь мы снова можем проверить текущий статус вызовем команду ```git status```.

**Мы видим:**
```
PS C:\Users\Dima\Desktop\Seminar1> git status

On branch master

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
  ```
<p style="color:red; text-indent: 220px;">modified:   Git_Education.md

```
no changes added to commit (use "git add" and/or "git commit -a")
PS C:\Users\Dima\Desktop\Seminar1>
```
**Git** говорит, что мы находимся на ветке master, он говорит, что у нас есть некоторые изменения, которые еще пока не подготовлены для сохранения, что у нас изменен файл **Git_Education.md** и он красненького цвета.

Давайте сохраним его новое состояние. Перед тем как сохранить нам нужно вызывать команду ```git add``` с указанием нашего файла, указать то что мы хотим сохранить именно в прежний файл, а не новый так как файлов может быть много, поэтому даже для отслеживаемых файлов перед тем как сохранить нам нужно вызывать команду ```git add```. В нашем случае это ```git add .\Git_Education.md``` .
Далее мы снова смотрим на статус командой: ```git status```.

**Мы видим:**
```
PS C:\Users\Dima\Desktop\Seminar1> git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
  ```
<p style="color:green; text-indent: 220px;">modified:   Git_Education.md

```
PS C:\Users\Dima\Desktop\Seminar1>
```
**Git сообщает**, что у нас файл стал зелененьким и есть изменения которые можно сохранить, создать *коммит (контрольную точку)*. 
Теперь мы можем создать **коммит**. Для этого вызовем команду: ```git commit -m "New title Git"``` .Если сообщений об ошибке не вышло значит все сделали верно.

Мы видим, что есть некоторые сохранения, теперь у нас есть уже два коммита с которыми можем работать.
Для того чтобы переходить от одной версии к другой или одной контрольной точки к другой. Хотелось бы видеть какие версии или контрольные точки существуют вообще у нас.

Для этого есть команда ```git log``` , некоторый журнал изменений, контрольных точек. Вызовем данную команду в ***терминале***.

Мы увидим: 

```
PS C:\Users\Dima\Desktop\Seminar1> git log
commit cb55c91b5f61e5d3c398724c96084c045c800940 (HEAD -> master)
Author: Dima <autodk@mail.ru>
Date:   Sat Aug 6 19:59:03 2022 +0300

    New Titile Git

commit 32e47f7f9766a70d54ce7f8cbface6325987abee
Author: Dima <autodk@mail.ru>
Date:   Sat Aug 6 19:50:17 2022 +0300

    initial commit
```
Мы видим наши **коммиты** их **имена** ранее заданные, **имя автора**, **дата создания** и **адрес коммита**, по которому мы можем перейти в ту или иную **контрольную и точку (коммит)**. Чтобы выйти из **loq** необходимо нажать клавишу **Q**.

Перейдем к начальной контрольной точке. Для этого наберем команду ```git checkout```. Мы можем указать название **commit** целиком либо **Git** позволяет на указать первые четыре символа.
Указываем команду ```git checkout``` и четыре символа сатуса: ```git сheckout 32e4``` и жмем **<d style="color:yellow">Enter</d>**.

В результате мы перешли к первой версии файла, у нас исчез Заголовок. Теперь можем вернуться обратно к прежней версии. Также задаем ```git checkout``` и четыре символа коммита прежней версии: ```git сheckout cb55```и жмем **<d style="color:orange">Enter</d>**.
Если все сделали верно, то увидите наш заголовок.

>**Но это ещё не всё.**

Теперь нужно нам вернуться на актуальное состояние, после того как переключались между контрольными точками, коммитами, чтобы можно было продолжить работу с файлом в штатном режиме.
Для этого нам нужно вызывать команду ```git checkout master```, **master** это название ветви, на которой мы работаем. После чего мы можем продолжить работу с нашим файлом в штатном режиме.

# Как сделать ветвление в Git

## Немного о ветвлении в Git основное
---

## Создание новой ветки

Чтобы создать новую ветку необходимо выполнить следующую команду:<br>`git branch name_branch` – данная команда создаст новую ветку с информацией которая была на момент создания в родительской ветке.

Например: 
<br>
```git branch shortlist```
После выполнения данной команды создаться ветка с именем shortlist.


## Просмотр всех веток с указанием активной ветки

Чтобы просмотреть все созданные ветки и узнать на какой мы находимся нужно выполнить команду: `*git branch*` – данная команда выведет все ветки и отметит звездочкой ветку на которой в данный момент находимся.

На экране появится следующее:

```
PS C:\Users\Dima\Desktop\Seminar1> git branch
  info_create_new_branch
* information_about_viewing_all_branches
  master
  ```
  Как видим из примера звездочкой отмечена та ветка, на которой мы находимся и работаем.


## Переключение веток

Чтобы перейти в другую созданную ветку и начать в ней работать нужно выполнить следующую команду: `*git checkout name_branch*` – выполнив данную команду мы перейдет на ветку которую мы укажем.

Для того, чтобы создать новую ветку и сразу перейти в нее необходимо выполнить команду: `*git  checkout -b shortlist2*` – данная команда создаст новую ветку _**shortlist2**_ и сразу перейдет в неё.

## Слияние веток

Чтобы провести слияние веток, необходимо переключиться на ветку, в которую вы хотите включить изменения из другой ветки применив команду `*git merge name_branche*`.
<br>Например если мы хотим произвести слияние веток shortlist1 и shortlist2 нам нужно переключиться на shortlist1 и выпонить команду: <br>`*git merge shortlist2*`.

## Удаление ненужных веток
Чтобы произвести удаление не нужной векти с которой работу закончили и провели слияние необходимо выполнить команду: 
<br>
`*git branch -d name_branche*` - данная команда удалит ненужную ветку. Если мы хотим удалить просто указываем:  `*git branch -d shortlist2*`.</br>


## Другие способы просмотра комитов и веток
Для того, чтобы просмотреть коммиты и созданные ветки с которыми мы работаем можно применить ещё следующие команды:
<br>`*git log –graph*` - выведет графическое представление комитов и веток в левой стороне терминала.</br>

`*git log --oneline --graph*` - выведет сокращенное графическое представление коммитов и веток.

`*git log –oneline –graph –all*` - данная команда выведет сокращенное гарфическое представление всех основных (последних) кометов и веток проекта в какой бы ветке вы не находились.

`*git branch --list*` - данная команда выведит перечень веток и звездочкой отметит на какой находимся.
`*git branch -v*`- данная команда выведит все ветки звездочкой отметит на какой ветке находимся, а также укажет идентификатор последнего комета и его название.

# Основные этапы работы с удаленным репозиторием

## Работа с удалёнными репозиториями
Для того, чтобы внести свои полезные задумки в какой-либо Git-проект, вам необходимо уметь работать с удалёнными репозиториями. Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее.
Рассмотрим какие команды нужны, чтобы начать работать с удаленными репозиториями.
## Добавление удалённых репозиториев
Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (origin), просто выполните команду git remote add ```<shortname>``` ```<url>```:<br>
git remote origin https://github.com/Elena/EveningRepository.git

### Просмотр удалённых репозиториев
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote.
Вы увидите следующее:
```
PS C:\Users\Dima\Desktop\Seminar2> git remote
Origin
```
Вы можете также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию, тогда вы увидите более полную информацию :
```
PS C:\Users\Dima\Desktop\Seminar2> git remote -v
origin  https://github.com/Elena/EveningRepository.git (fetch)
origin  https://github.com/Elena/EveningRepository.git (push)
```

### Получение изменений из удалённого репозитория — Fetch и Pull
Для получения новых данных из удалённых проектов, следует выполнить:
```
$ git fetch [remote-name]
```
Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.
Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, _**git fetch origin**_ извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью _**fetch**_). Важно отметить, что команда _**git fetch**_ забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.
Если ветка настроена на отслеживание удалённой ветки , то вы можете использовать команду _**git pull**_ чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда git clone автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение _**git pull**_, как правило, извлекает _**fetch**_ данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить _**merge**_ их с кодом, над которым вы в данный момент работаете.

### Отправка изменений в удаленный репозиторий (Push)
Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: ```git push <remote-name> <branch-name>```. Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:
```
$ git push origin master
```
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись т.е. вы можете отправить на свой репозиторий сделанный на **GitHub** или который скопировали при помощи функции **Fork**, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а после него выполнить команду **git push** попытаетесь вы, то ваш push точно будет отклонён. Вам придётся сначала получить изменения выполнить команду **git pull** и объединить их с вашими и только после этого вам будет позволено выполнить **git push**.

## Как произвести добавление локальных изменений в свой удаленный репозиторий на GitHub
---
Для начала вы должны зарегистрироваться на GitHub и произвести авторизацию.

После чего добавить репозиторий на сервере **GitHub** в своем личном кабинете или профиле **GitHub**. Открываем меню нажимаем на стрелочку с вашей аватаркой и выбираем Your repositories (Ваши репозитрии)  Ищем зеленую кнопочку New (Новый) репозитрий Задаем в поле Repository name, имя нового вашего репозитория смотрим на переключатели **Public (Публичный)** или **Private (Приватный)**, так как мы хотим. Чтобы к нашему проекту был доступ у других пользователей **GitHub** оставляем без изменений переключатель на **Public**. Жмем **Сreate repository (Создать репозиторий)**.
Далее **GitHub** нам предлагает, как мы можем поступить дальше:
````
…or create a new repository on the command line
...или создайте новый репозиторий в командной строке
echo "# EveningRepository" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/Elena/EveningRepository.git
git push -u origin main

…or push an existing repository from the command line
...или запустите существующий репозиторий из командной строки
git remote add origin https://github.com/Elena/EveningRepository.git
git branch -M main
git push -u origin main

````
Но так как у нас есть репозиторий локальный который мы хотим разместить на **GitHub**, то мы запустим существующий репозиторий из командной строки и выполним набор команд из второго условия но основную ветку оставим прежней master:
```
git remote add origin https://github.com/Elena/EveningRepository.git
git branch -M master
git push -u origin master
```
В конечном результате мы наш локальный проект увидим на сервере **GitHub**.
Теперь вернемся в локальный репозиторий и внесем изменения в наш проект, например добавим строку “Добавила строчку на локальном репозитории совмещенном с удаленным на **GitHub**, сохраним, добавим коммит далее, чтобы нам эти изменения разместить на удаленный проект с которым мы уже связаны нужно выполнить команду **git push** после чего наша строчка добавитьcя в удаленный проект на сервере **GitHub**.
Давайте теперь перейдем в наш профиль на GitHab в данный репозиторий и внесем там изменения, как будто кто-то внес изменения в наш проект.
Откроем наш файл с которым мы работаем и нажмем на карандашик и внесем сроку _“Добавила строчку в GitHub editor и залью на локальную машину”_. 
Далее в разделе **Commit changes (фиксация изменений)**  в поле где подсказка  **Create (создать)** напишем комментарий нашего коммита например _“Создали строку на GitHub”_  и жмем на позеленевшую кнопку **Commit changes**.

Теперь у нас ситуация, что изменения в удаленном репозитории есть, а на локальном нету.
Вернемся в локальный репозиторий и выполним команду **git pull**.
На экране будет следующее:
````
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), 698 bytes | 49.00 KiB/s, done.
From https://github.com/Elena/EveningRepository
   c843d7c..7a6331b  master     -> origin/master
Updating c843d7c..7a6331b
Fast-forward
 Git_seminar2.md | 1 +
 1 file changed, 1 insertion(+)

````
Из данной информации видно, что наш локальный git установил соединение с удаленным репозиторием увидел там новые изменения на в ветке **origin/master** и переносит новые изменения в локальный репозиторий ветку master, путем слияния веток по технологии **Fast-forward** в файл **Git_seminar2.md** вставил одно изменение.


## Как произвести Fork публичного репозитория, добавить на локальную машину внести изменения и произвести pull requests
---


### Произвести Fork публичного репозитория
Данный вопрос разберем на примере публичного репозитория **EveningRepository** в личном кабинете **nickname PavelGeekBrains** переходим по ссылке https://github.com/PavelGeekBrains/EveningRepository

Жмем на кнопку **Fork** в правой верхней стороне, попадаем в раздел **Create a new fork** 
В поле **Repository name** оставляем тоже имя или можем его немного изменить, галочку с **Copy the master branch only** не снимаем оставляем так как нам и нужна только основная ветка **master**, после чего жмем на зеленую кнопку **Create Fork**, после чего данный репозиторий скопируется в наш личный кабинет в наши репозитории на **GitHub** и мы сразу попадем в окно где он будет открыт в нашем кабинете на **GitHub**. После чего ищем кнопу **Code** нажимаем на нее и копируем ссылку https://github.com/Elena/EveningRepository.git

### Добавить репозиторий после Fork на локальную машину внести изменения

### Добавить репозиторий после Fork на локальную машину
После чего переходим на локальную машину и создаем папку на рабочем столе **EveningRepository**, открываем **VS Code** и в **Explorer (Проводник)** выбираем кнопку **Clone Repository (Клонировать репозиторий)**, откроется меню в котором нужно вставить нашу ссылку https://github.com/Elena/EveningRepository.git, далее жмем команду **Clone from GitHub (клонировать из GitHub)**, откроется окно в котором нужно нажать **Открыть**. Вы также увидите возможность клонирования с GitHub. Как только вы пройдете аутентификацию с помощью своей учетной записи **GitHub** в **VS Code**, вы сможете выполнять поиск по репозиториям по имени и выбирать любое хранилище для его клонирования. В томже меню где вводили ссылку появятся наши репозитории выбираем наш и нажимаем на него откроется **окно с Выбор папки**, выбираем нашу ранее созданную папку и нажимаем **Выбрать расположение репозитория**, далее пройдет обработка и появится окно:

_Вы хотите открыть клонированный репозиторий?_ Источник:Git в котором жмем кнопку **Открыть**. После чего произойдет чудо и наш проект добавится на локальную машину.
### Внести изменения и отправить их на GitHub
Теперь можно создать новую ветку ```git checkout -b Newbranch```, далее внесем в неё изменения например добавим строку **_“Эта строка внесена в новой ветке и будет отправлена на добавление в проект”_**, далее сохраняем добавляем в файл ``git add .\GitEducation.md``, делаем коммит ``git commit -m”New line”`` после чего нам нужно направить эти изменения на удаленный репозиторий, чтобы нам это сделать нужно применить команду ``git push`` но в таком виде она не пройдет, а нужно выполнить команду ```git push --set-upstream origin newbranch```.

Данной командой мы передаем новую ветку в удаленный репозиторий устанавливаем связь с ней и отправляем все произведенные изменения в ней, если в дальнейшем мы произведем какие-то изменения по тексту, сохраним их, то нам достаточно будет выполнить команду ``git push``.

### Произвести запрос на pull requests
После того как мы отправили изменения на сервер мы должны перейти в личный кабинет **GitHub** с данным репозиторием. Где вы увидите  раздел с информацией _**newbranch had recent pushes less than a minute ago**_ о том , что мы прислали на сервер новую ветку newbranch с изменениями и **GitHub** предлагает нам сделать **Compare & Pull request** (данная кнопка будет в данном разделе и подсвечена зеленым цветом) некий запрос владельцу проекта на сравнение и извлечение данной информации, т.е. принятия нашего решения или нет. Жмем на кнопку **Compare & Pull request** перейдем на страницу создания запроса в поле текста с подсказкой что нам сделать **Leave a comment (Оставить комментарий)**, оставляем свой комментарий к данным изменениям который хотим направить владельцу проекта и жмем кнопку **Create pull request (Создать запрос на вытягивание, т.е. на включение нашего предложения в проект)**, после чего запрос сформируется.

>>Расскажу еще немного про язык Markdown.

---

# Немного про Markdown

## Создание заголовков
---

Чтобы создать заголовок нужно в начале строки добавить решетку поставить пробел и написать текст, для загловка первого уровня #, для заголовка второго уровня ##, для зоголовка третьего уровня ###.

**Мы увидим:**

# Первого уровня  - ```# Первого уровня```
## Второго уровня - ```## Второго уровня```
### Третьего уровня - ```### Третьего уровня```
> Идем далее ->

## Создание ненумерованного и нумерованного списка
Чтобы создать ненумерованный список нам достаточно в начале строки поставить **"*"** сделать пробел и написать текст, а для нумерованного списка в начале строки поставить цифру и точку и сделать пробел - **"1."**.
### Ненумерованный список
---
Задаем: 

```* Элемент 1```

```* Элемент 2```

Получаем:

* Элемент 1
* Элемент 2

### Нумерованный список
---
Задаем: 

```1. Элемент 1```

```2. Элемент 2```

Получаем:

1. Элемент 1
2. Элемент 2
<br>
</br>

## Выделение текста

Чтобы выделить текст *курсивом* достаточно обрамить слово или весь текст одной "*":

 ```*пример1*```, *пример1*.
 <br>
 </br>
Чтобы выделить текст **полужирным** достаточно обрамить слово или текст двумя "**":

 ```**пример2**```, **пример2**.
 <br>
 </br>
 Чтобы выделить текст ***полужирным курсивным*** достаточно обрамить слово или текст тремя "***":

```***пример3***```, ***пример3***.
 <br>
 </br>
***<b  style="color:green">Пока все о чем хотелось рассказать.***
